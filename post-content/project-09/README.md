# Final Project #9 : The Lean, Mean, Turing Machine!

Having assembled the full machine (and tampered with the memory to motor attachment a bit) I was able to get the machine fully operational! In the two videos below, the Turning Machine is running a program that increments the binary number in memory by one. Though, the Arduino program is capable of running any valid Turing Machine program is it given (in the format of a C data structure). The first video is a more polished demo - but unfortunately the machine wasn't able to count very far, so I also included the second video. It's not as good a demo, but in that video it counts up to four! (It's also a good demonstration of the failure-to-write failsafe.)

[You can see the complete code for the final machine on GitHub.](https://github.com/JoshIsAStudent/physical-computing/tree/main/final-project/arduino-program)

?[youtube-video](WRYNrWkzYCs)

?[youtube-video](npGdXoWBmCI)

## Project Evaluation
Overall I am really happy with how the project turned out! Though the poor thing is a bit janky, it is a successful proof of concept. Though not practical at face value, I could envision a working version of the machine being used to help teach computing principles in a more hands-on way. And beyond any practical purpose, it is a surprising enguaging machine to watch in action when it works.

### What was learned
From the start of my initial experiments to the end of my final project, I've been surpised by how many components are - at the tinker's level - essentially "plug-and-play". Obviously this is in great part due to the huge number of libraries and tutorials that have been made by other people, but the ability to - for example - plug in an infrared receiver and pretty quickly start sending instructions to other hardware is very compelling. Once you start doing more complicated things though, it is definately important to grow a foundational understanding of electonrics. I've learned that often, when making a component work, the devil's in the details. Be that knowing how much power a component needs to drive, how different libraries interact, or the importance of a shared ground!

As I noted in an early post, I also thought it's been interesting to see how frquently potential divier circuits are used in electronics. Though they can be sometimes abstracted away by the plug-and-play nature of the environment, it's been interesting to play attention to some of the funamental features of electronics that reappear often.

### Opportunities for Development
I think the most apparent way in which the project could be developed further is through more sophisticed manufacture of the physical components. The electronics and code of the machine work flawlessly, however persistent issues with the [disc memory](https://physicalcomputingwithj.tumblr.com/post/652204965729845248) and the memory cells mean that [accumulation of error](https://en.wikipedia.org/w/index.php?title=Accumulation_of_errors) quickly brings the machine into critial error (sometimes even just one error throws everything off!). In principle, the issues of rotating the disc could be resolved by replacing the stepper motor with a DC motor and putting limit switches at the position of each memory cell so the program can tell when it has successfully rotated to a cell. In practise though, I can also imagine each indiviual limit switch becoming a potential point of failure in and of itself; [the best part is no part](https://youtu.be/pyf_T-rhVK8?t=165), as they say. And besides that, the issues writing to the bits are not so easy to resolve. The precision offered by factory made parts or custom parts manufactured with proper tools (be that more traditional workshop tools, 3D printing, or anything else), would make the machine much more reliable.

The key benefit of making the machine more reliable is it could be made to operate on far more bits - which is another way the project could be developed further. A larger memory would allow for more sophisticed programs to be run. Though a mechanical computer such as this will never get anything close to even some of the easiest digital machines in terms of scale and speed, with enough memory some interseting (if trivial) programs could still be executed. There is an underlying limitation of the current design which - if addressed - could make it much easier to add more memory to the machine. Currently, the size of the memory and the hardware of the machine are couppled to one anthoer. In other words, if you wanted to make the memory disc bigger (or memory cells smaller), you would have to adjust the machine's hardware to be able to accomdate for this. If you consider Turing's hypothetical machine however, becuse it moves over a strip of paper, the paper can be of any size, and the machine will remain the same. If the size of the memory and hardware of the machine could be decouppled, running much larger programs becomes _\*more\*_ feasable. If a sufficiently large memory could be achieved, you could even adapt the Turning machine to read it's program from memory, instead of it being stored on the Arduino.
